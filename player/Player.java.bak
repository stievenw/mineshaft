package com.mineshaft.player;

import com.mineshaft.block.Block;
import com.mineshaft.block.Blocks;
import com.mineshaft.core.Settings;private static final float PLAYER_WIDTH=0.6f;private static final float EYE_HEIGHT=1.62f;private static final float EYE_HEIGHT_SNEAKING=1.54f;

// Physics constants
private static final float GRAVITY=-0.08f;private static final float WATER_GRAVITY=-0.02f;private static final float JUMP_STRENGTH=0.50f;private static final float WATER_SWIM_SPEED=0.25f;private static final float WATER_JUMP_BOOST=0.35f;private static final float TERMINAL_VELOCITY=-3.92f;private static final float WATER_TERMINAL_VELOCITY=-0.08f;private static final float MAX_WATER_UP_SPEED=0.30f;

// Movement constants
private static final float STEP_HEIGHT=0.6f;private static final float GROUND_SNAP_DISTANCE=0.02f;private static final float SNEAK_SPEED_MULTIPLIER=0.3f;

private final long window;private World world;private Inventory inventory;

// Game state
private GameMode gameMode=GameMode.CREATIVE;private boolean flying=true;private boolean inWater=false;private boolean headInWater=false;private boolean sprinting=false;private boolean sneaking=false;

// Movement tracking for animations
private double velocityX=0;private double velocityZ=0;private double prevX=0;private double prevZ=0;

public Player(World world,long window){super(null);this.world=world;this.window=window;this.inventory=new Inventory();this.prevX=x;this.prevZ=z;}

/**
 * ✅ Process movement input (called every frame for smooth movement)
 */
public void processMovementInput(float frameDelta){
// Store previous position
prevX=x;prevZ=z;

// Process movement
processMovement(frameDelta);

// Calculate velocity based on position change
velocityX=x-prevX;velocityZ=z-prevZ;}

/**
 * ✅ Physics update (called at fixed 20 TPS)
 */
@Override public void tick(){checkWaterStatus();

if(!flying&&gameMode==GameMode.SURVIVAL){if(inWater){applyWaterPhysics(1.0f/Settings.TARGET_TPS);}else{applyPhysics(1.0f/Settings.TARGET_TPS);}}}

/**
 * ✅ Process all movement input
 */
private void processMovement(float delta){
// Check sneaking state (Left Shift)
boolean shiftPressed=glfwGetKey(window,GLFW_KEY_LEFT_SHIFT)==GLFW_PRESS;

// Update sneaking state
if(!flying){sneaking=shiftPressed;}else{sneaking=false; // Cannot sneak while flying
}

// Base movement speed
float speed=Settings.WALK_SPEED*delta;

// Apply sprint modifier (Left Control)
boolean controlPressed=glfwGetKey(window,GLFW_KEY_LEFT_CONTROL)==GLFW_PRESS;

if(controlPressed&&!sneaking){speed=Settings.SPRINT_SPEED*delta;sprinting=true;}else{sprinting=false;}

// Apply sneak modifier
if(sneaking){speed*=SNEAK_SPEED_MULTIPLIER;}

// Apply water modifier
if(inWater&&!flying){speed*=0.5f;}

// Apply spectator modifier
if(gameMode==GameMode.SPECTATOR){speed*=2.0f;}

// Calculate movement direction
float moveX=0,moveZ=0;

if(glfwGetKey(window,GLFW_KEY_W)==GLFW_PRESS){moveX+=(float)Math.sin(Math.toRadians(yaw))*speed;moveZ-=(float)Math.cos(Math.toRadians(yaw))*speed;}if(glfwGetKey(window,GLFW_KEY_S)==GLFW_PRESS){moveX-=(float)Math.sin(Math.toRadians(yaw))*speed;moveZ+=(float)Math.cos(Math.toRadians(yaw))*speed;}if(glfwGetKey(window,GLFW_KEY_A)==GLFW_PRESS){moveX+=(float)Math.sin(Math.toRadians(yaw-90))*speed;moveZ-=(float)Math.cos(Math.toRadians(yaw-90))*speed;}if(glfwGetKey(window,GLFW_KEY_D)==GLFW_PRESS){moveX+=(float)Math.sin(Math.toRadians(yaw+90))*speed;moveZ-=(float)Math.cos(Math.toRadians(yaw+90))*speed;}

// Apply horizontal movement
if(moveX!=0||moveZ!=0){if(gameMode==GameMode.SPECTATOR){x+=moveX;z+=moveZ;}else{moveWithCollisionAndStep(moveX,moveZ);}}

// Vertical movement (flying/swimming)
if(flying){handleFlyingVerticalMovement(speed);}else{handleJumping();}}

/**
 * ✅ Handle vertical movement while flying
 */
private void handleFlyingVerticalMovement(float speed){float moveY=0;

// Space = up
if(glfwGetKey(window,GLFW_KEY_SPACE)==GLFW_PRESS){moveY=speed*2;}

// Shift = down (but only when flying, not sneaking on ground)
if(glfwGetKey(window,GLFW_KEY_LEFT_SHIFT)==GLFW_PRESS){moveY=-speed*2;}

if(moveY!=0){if(gameMode==GameMode.SPECTATOR){y+=moveY;}else{if(!isColliding(x,y+moveY,z)){y+=moveY;}}}}

/**
 * ✅ Handle jumping and swimming
 */
private void handleJumping(){boolean spaceDown=glfwGetKey(window,GLFW_KEY_SPACE)==GLFW_PRESS;

if(!spaceDown)return;

if(inWater){if(onGround){velocityY=WATER_JUMP_BOOST;onGround=false;}else{velocityY=WATER_SWIM_SPEED;}}else{if(onGround&&!sneaking){ // Cannot
                                                                                                                                    // jump
                                                                                                                                    // while
                                                                                                                                    // sneaking
velocityY=JUMP_STRENGTH;onGround=false;}}}

/**
 * ✅ Move with collision detection and step-up
 */
private void moveWithCollisionAndStep(float dx,float dz){if(world==null){x+=dx;z+=dz;return;}

float newX=x+dx;float newZ=z+dz;

// Check collision at new position
if(!isColliding(newX,y,newZ)){x=newX;z=newZ;return;}

// Try stepping up (not while sneaking)
boolean canStep=!sneaking&&(onGround||isOnGroundCheck(x,y,z)||inWater);

if(canStep){
// Try common step heights first
float[]commonSteps={0.5f,STEP_HEIGHT,0.4f,0.3f,0.2f,0.1f};

for(float stepHeight:commonSteps){if(stepHeight>STEP_HEIGHT)continue;

float testY=y+stepHeight;

if(!isColliding(newX,testY,newZ)){x=newX;z=newZ;y=testY;

if(inWater&&velocityY<0.1f){velocityY=0.1f;}

return;}}

// Try fine-grained stepping
for(float stepHeight=0.05f;stepHeight<=STEP_HEIGHT;stepHeight+=0.05f){float testY=y+stepHeight;

if(!isColliding(newX,testY,newZ)){x=newX;z=newZ;y=testY;

if(inWater&&velocityY<0.1f){velocityY=0.1f;}

return;}}}

// Slide along walls
float oldX=x;float oldZ=z;

if(!isColliding(newX,y,oldZ)){x=newX;}

if(!isColliding(oldX,y,newZ)){z=newZ;}}

/**
 * ✅ Find ground Y position below player
 */
private float getGroundYBelow(float px,float py,float pz){if(world==null)return-1;

float halfWidth=PLAYER_WIDTH/2;

int minX=(int)Math.floor(px-halfWidth);int maxX=(int)Math.floor(px+halfWidth);int minZ=(int)Math.floor(pz-halfWidth);int maxZ=(int)Math.floor(pz+halfWidth);

int startY=(int)Math.floor(py);int searchDepth=15;

int highestGroundY=-1;

for(int checkY=startY;checkY>=startY-searchDepth&&checkY>=0;checkY--){for(int bx=minX;bx<=maxX;bx++){for(int bz=minZ;bz<=maxZ;bz++){Block block=world.getBlock(bx,checkY,bz);

if(block.isSolid()){highestGroundY=Math.max(highestGroundY,checkY);}}}

if(highestGroundY!=-1){break;}}

if(highestGroundY!=-1){return highestGroundY+1.0f;}

return-1;}

/**
 * ✅ Check if player is in water
 */
private void checkWaterStatus(){if(world==null){inWater=false;headInWater=false;return;}

int checkX=(int)Math.floor(x);int checkZ=(int)Math.floor(z);

// Check head position
int headY=(int)Math.floor(y+getCurrentEyeHeight()-0.1f);Block headBlock=world.getBlock(checkX,headY,checkZ);headInWater=(headBlock==Blocks.WATER);

// Check body position
int bodyY=(int)Math.floor(y+getCurrentHeight()*0.5f);Block bodyBlock=world.getBlock(checkX,bodyY,checkZ);

// Check feet position
int feetY=(int)Math.floor(y+0.4f);Block feetBlock=world.getBlock(checkX,feetY,checkZ);

inWater=(bodyBlock==Blocks.WATER)||(feetBlock==Blocks.WATER);}

/**
 * ✅ Apply water physics
 */
private void applyWaterPhysics(float delta){velocityY+=WATER_GRAVITY;

if(velocityY<WATER_TERMINAL_VELOCITY){velocityY=WATER_TERMINAL_VELOCITY;}

if(velocityY>MAX_WATER_UP_SPEED){velocityY=MAX_WATER_UP_SPEED;}

float newY=y+velocityY;

if(velocityY<=0){if(isOnGroundCheck(x,newY,z)){float groundY=getGroundYBelow(x,newY,z);if(groundY>0){y=groundY;velocityY=0;onGround=true;}else{y=newY;onGround=false;}}else{y=newY;onGround=false;}}else{if(isCeilingCollision(x,newY,z)){velocityY=0;}else{y=newY;}onGround=false;}}

/**
 * ✅ Apply gravity and ground physics
 */
private void applyPhysics(float delta){
// Ground snap when standing still
if(onGround&&velocityY==0){float groundY=getGroundYBelow(x,y,z);

if(groundY>0){float distToGround=y-groundY;

if(Math.abs(distToGround)<0.001f){y=groundY;return;}else if(distToGround>0&&distToGround<GROUND_SNAP_DISTANCE){y=groundY;return;}else if(distToGround<-0.1f){y=groundY;velocityY=0;return;}else if(distToGround>GROUND_SNAP_DISTANCE){onGround=false;}}else{onGround=false;}}

// Apply gravity
velocityY+=GRAVITY;

if(velocityY<TERMINAL_VELOCITY){velocityY=TERMINAL_VELOCITY;}

float newY=y+velocityY;

// Falling/landing
if(velocityY<=0){if(isOnGroundCheck(x,newY,z)){float groundY=getGroundYBelow(x,newY,z);

if(groundY>0){y=groundY;velocityY=0;onGround=true;

// Fix if stuck in block
if(isColliding(x,y,z)){for(float offset=0.01f;offset<=0.5f;offset+=0.01f){if(!isColliding(x,groundY+offset,z)){y=groundY+offset;break;}}}

return;}}}
// Rising
else{if(isCeilingCollision(x,newY,z)){velocityY=0;newY=y;}}

y=newY;onGround=false;}

/**
 * ✅ Check collision with current player height (accounts for sneaking)
 */
private boolean isColliding(float px,float py,float pz){if(world==null)return false;

float halfWidth=PLAYER_WIDTH/2;float currentHeight=getCurrentHeight();

int minX=(int)Math.floor(px-halfWidth);int maxX=(int)Math.floor(px+halfWidth);int minY=(int)Math.floor(py);int maxY=(int)Math.floor(py+currentHeight-0.01f);int minZ=(int)Math.floor(pz-halfWidth);int maxZ=(int)Math.floor(pz+halfWidth);

for(int bx=minX;bx<=maxX;bx++){for(int by=minY;by<=maxY;by++){for(int bz=minZ;bz<=maxZ;bz++){Block block=world.getBlock(bx,by,bz);if(block.isSolid()){return true;}}}}

return false;}

/**
 * ✅ Check if player is on ground
 */
private boolean isOnGroundCheck(float px,float py,float pz){if(world==null)return false;

float halfWidth=PLAYER_WIDTH/2;int checkY=(int)Math.floor(py-0.01f);

int minX=(int)Math.floor(px-halfWidth);int maxX=(int)Math.floor(px+halfWidth);int minZ=(int)Math.floor(pz-halfWidth);int maxZ=(int)Math.floor(pz+halfWidth);

for(int bx=minX;bx<=maxX;bx++){for(int bz=minZ;bz<=maxZ;bz++){Block block=world.getBlock(bx,checkY,bz);if(block.isSolid()){return true;}}}

return false;}

/**
 * ✅ Check ceiling collision
 */
private boolean isCeilingCollision(float px,float py,float pz){if(world==null)return false;

float halfWidth=PLAYER_WIDTH/2;float currentHeight=getCurrentHeight();int checkY=(int)Math.floor(py+currentHeight+0.01f);

int minX=(int)Math.floor(px-halfWidth);int maxX=(int)Math.floor(px+halfWidth);int minZ=(int)Math.floor(pz-halfWidth);int maxZ=(int)Math.floor(pz+halfWidth);

for(int bx=minX;bx<=maxX;bx++){for(int bz=minZ;bz<=maxZ;bz++){Block block=world.getBlock(bx,checkY,bz);if(block.isSolid()){return true;}}}

return false;}

/**
 * ✅ Toggle flying mode
 */
public void toggleFlying(){if(gameMode.canFly()){flying=!flying;if(flying){velocityY=0;sneaking=false; // Stop sneaking
                                                                                                       // when flying
}System.out.println("Flying: "+(flying?"ON":"OFF"));}else{System.out.println("Cannot fly in "+gameMode.getName()+" mode!");}}

// ========================================
// GETTERS
// ========================================

/**
 * ✅ Get current player height (changes when sneaking)
 */
public float getCurrentHeight(){return sneaking?PLAYER_HEIGHT_SNEAKING:PLAYER_HEIGHT;}

/**
 * ✅ Get current eye height (changes when sneaking)
 */
public float getCurrentEyeHeight(){return sneaking?EYE_HEIGHT_SNEAKING:EYE_HEIGHT;}

/**
 * ✅ Get eye Y position (for camera and rendering)
 */
public float getEyeY(){return y+getCurrentEyeHeight();}

/**
 * ✅ Check if player is currently moving (for animations)
 */
public boolean isMoving(){return Math.abs(velocityX)>0.001||Math.abs(velocityZ)>0.001;}

/**
 * ✅ Check if player is sneaking
 */
public boolean isSneaking(){return sneaking;}

/**
 * ✅ Get horizontal velocity magnitude (for animations)
 */
public double getHorizontalVelocity(){return Math.sqrt(velocityX*velocityX+velocityZ*velocityZ);}

public double getVelocityX(){return velocityX;}public double getVelocityZ(){return velocityZ;}public GameMode getGameMode(){return gameMode;}public Inventory getInventory(){return inventory;}public boolean isFlying(){return flying;}public boolean isInWater(){return inWater;}public boolean isHeadInWater(){return headInWater;}public boolean isSprinting(){return sprinting;}public World getWorld(){return world;}

// ========================================
// SETTERS
// ========================================

/**
 * ✅ Set game mode
 */
public void setGameMode(GameMode mode){this.gameMode=mode;

if(mode==GameMode.CREATIVE||mode==GameMode.SPECTATOR){flying=true;velocityY=0;sneaking=false;}else{flying=false;}

System.out.println("Game mode: "+mode.getName());}

public void setWorld(World world){this.world=world;}}